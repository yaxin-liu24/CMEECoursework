print(total_simulations)
print("Final extinction counts per condition:")
print(extinction_counts)
# 生成图表
png(filename = "question_5.png", width = 600, height = 400)
barplot(proportions,
names.arg = c("Adults Large", "Adults Small", "Mixed Large", "Mixed Small"),
col = "steelblue",
main = "Extinction Proportion by Initial Condition",
xlab = "Initial Condition",
ylab = "Proportion of Extinctions")
Sys.sleep(0.1)  # 确保图像正确保存
dev.off()
# 找出灭绝比例最高的初始条件
most_extinct <- c("Adults Large", "Adults Small", "Mixed Large", "Mixed Small")[which.max(proportions)]
# 返回解释性文本
return(paste("The population with initial condition '", most_extinct,
"' was most likely to go extinct. This suggests that lower initial population sizes or weaker population structures increase extinction risk.", sep = ""))
}
question_5()
files <- list.files(pattern = "*.RData")
iter_values <- as.numeric(gsub("\\D", "", files))
print(iter_values[iter_values %% 4 == 0])
setwd("~/Desktop/HPC")
# Question 7
species_richness <- function(community){
richness=length(unique(community))
return(richness)
}
# Question 8
init_community_max <- function(size){
max_species = seq_len(size)
return(max_species)
}
# Question 9
init_community_min <- function(size){
min_species = rep(1,size)
return(min_species)
}
# Question 10
choose_two <- function(max_value){
sample(1:max_value, 2)
}
# Question 11
neutral_step <- function(community){
# Use choose_two to pick two distinct indices from the community vector.
inds <- choose_two(length(community))
# The first index is the individual to die.
# The second index is the individual that reproduces.
community[inds[1]] <- community[inds[2]]
# Return the updated community.
return(community)
}
# Question 12
neutral_generation <- function(community){
# 获取社区中个体的数量
n <- length(community)
# 确定一个世代所需的中性步骤次数
# 如果 n 为偶数，则 steps = n/2；如果 n 为奇数，则随机选择 floor(n/2) 或 ceiling(n/2)
if (n %% 2 == 0) {
steps <- n / 2
} else {
steps <- sample(c(floor(n / 2), ceiling(n / 2)), 1)
}
# 执行多个中性步骤来模拟一个世代的变化
for (i in 1:steps) {
community <- neutral_step(community)
}
# 返回经过一个世代后的社区状态
return(community)
}
# Question 13
neutral_time_series <- function(community,duration)  {
# Initialize a vector to store species richness over time.
# We store the initial richness plus one value per generation.
richness_series <- numeric(duration + 1)
# Record species richness of the initial community.
richness_series[1] <- length(unique(community))
# Loop over the number of generations.
for (i in 1:duration) {
# Update the community by one generation.
community <- neutral_generation(community)
# Record the species richness (number of unique species).
richness_series[i + 1] <- length(unique(community))
}
# Return the time series vector.
return(richness_series)
}
# Question 14
question_14 <- function() {
# Initialize the community with maximum diversity:
# Each of the 100 individuals represents a unique species.
community <- init_community_max(100)
# Run the neutral model simulation for 200 generations.
# The function neutral_time_series returns a time series vector of species richness,
# starting from the initial condition.
richness_ts <- neutral_time_series(community, duration = 200)
png(filename="question_14", width = 600, height = 400)
# plot your graph here
plot(richness_ts, type = "l",
xlab = "Generation",
ylab = "Species Richness",
main = "Neutral Model Simulation: Species Richness Over Generations")
Sys.sleep(0.1)
dev.off()
# Return the answer to the question in plain text.
answer <- "The system will eventually converge to monodominance (species richness of 1). This is because in a neutral model without speciation, random drift eventually leads to the extinction of all species except one, resulting in an absorbing state."
return(answer)
}
# Question 15
neutral_step_speciation <- function(community,speciation_rate)  {
# Use choose_two to randomly pick two distinct indices in the community.
inds <- choose_two(length(community))
# The first index is the individual that dies.
# The second index is used for reproduction if speciation does not occur.
death_index <- inds[1]
repro_index <- inds[2]
# Generate a random number to decide whether speciation occurs.
if (runif(1) < speciation_rate) {
# SPECATION EVENT:
# Determine a new species number that is not present in the current community.
# One simple method is to take the maximum current species number and add 1.
new_species <- max(community) + 1
community[death_index] <- new_species
} else {
# REPRODUCTION EVENT (as in neutral_step):
# Replace the dead individual with the offspring of the reproducing individual.
community[death_index] <- community[repro_index]
}
# Return the updated community vector.
return(community)
}
# Question 16
neutral_generation_speciation <- function(community,speciation_rate)  {
# Get the number of individuals in the community.
n <- length(community)
# Determine the number of neutral steps (birth-death events) to constitute one generation.
# If n is even, then n/2 steps represent one generation.
# If n is odd, randomly choose between floor(n/2) and ceiling(n/2).
if (n %% 2 == 0) {
steps <- n / 2
} else {
steps <- sample(c(floor(n / 2), ceiling(n / 2)), 1)
}
# Perform the simulation steps using the speciation rule.
# For each step, use neutral_step_speciation to update the community.
for (i in 1:steps) {
community <- neutral_step_speciation(community, speciation_rate)
}
# Return the updated community after one generation.
return(community)
}
# Question 17
neutral_time_series_speciation <- function(community,speciation_rate,duration)  {
# Initialize a vector to store species richness for each generation.
# The vector has length duration + 1 to include the initial condition.
richness_series <- numeric(duration + 1)
# Record the species richness of the initial community.
richness_series[1] <- length(unique(community))
# Loop over each generation.
for (i in 1:duration) {
# Advance the community one generation using the neutral model with speciation.
community <- neutral_generation_speciation(community, speciation_rate)
# Record the species richness (number of unique species) after this generation.
richness_series[i + 1] <- length(unique(community))
}
# Return the time series vector of species richness.
return(richness_series)
}
# Question 18
question_18 <- function() {
png(filename="question_18", width = 600, height = 400)
# plot your graph here
# Set simulation parameters
community_size <- 100
speciation_rate <- 0.1
duration <- 200
# Create two different initial communities:
# - Maximal diversity: each individual is a unique species.
community_max <- init_community_max(community_size)
# - Minimal diversity: all individuals belong to the same species.
community_min <- init_community_min(community_size)
# Run the simulation with speciation for both initial conditions.
# neutral_time_series_speciation returns a vector of species richness over generations.
richness_max <- neutral_time_series_speciation(community_max, speciation_rate, duration)
richness_min <- neutral_time_series_speciation(community_min, speciation_rate, duration)
# Plot the time series for the maximal diversity initial condition in red.
plot(richness_max, type = "l", col = "red", lwd = 2,
xlab = "Generation", ylab = "Species Richness",
main = "Neutral Model Simulation with Speciation")
# Overlay the time series for the minimal diversity initial condition in blue.
lines(richness_min, type = "l", col = "blue", lwd = 2)
# Add a legend to differentiate the two curves.
legend("topright", legend = c("Max Diversity", "Min Diversity"),
col = c("red", "blue"), lwd = 2)
Sys.sleep(0.1)
dev.off()
return("The plot demonstrates that regardless of whether the simulation starts with maximal or minimal diversity, the neutral model with speciation converges to a similar dynamic equilibrium in species richness over time. This occurs because the stochastic processes of random drift and speciation eventually override the influence of the initial conditions, leading to a characteristic equilibrium state.")
}
# Question 19
species_abundance <- function(community) {
abundances <- table(community)
return(sort(as.numeric(abundances), decreasing = TRUE))
}
# Question 20
octaves <- function(abundance_vector) {
if (length(abundance_vector) == 0) {
return(numeric(0)) # 返回空数值向量
}
octave_classes <- floor(log2(abundance_vector)) + 1
octave_counts <- tabulate(octave_classes)
return(octave_counts)
}
# Question 21
sum_vect <- function(x, y) {
len_x = length(x)
len_y = length(y)
if (len_x < len_y){
x = c(x,rep(0,len_y-len_x))
}
if (len_x > len_y){
y = c(y,rep(0,len_x-len_y))
}
return(x+y)
}
# Question 22
question_22 <- function() {
# Simulation parameters
community_size <- 100
speciation_rate <- 0.1
burn_in <- 200
duration <- 2000
interval <- 20  # Record every 20 generations
# Initialize communities
community_max <- init_community_max(community_size)
community_min <- init_community_min(community_size)
# Burn-in phase
for (i in 1:burn_in) {
community_max <- neutral_generation_speciation(community_max, speciation_rate)
community_min <- neutral_generation_speciation(community_min, speciation_rate)
}
# Initialize lists to store octave vectors
octaves_max <- list()
octaves_min <- list()
# Main simulation loop (2000 generations)
for (i in 1:duration) {
community_max <- neutral_generation_speciation(community_max, speciation_rate)
community_min <- neutral_generation_speciation(community_min, speciation_rate)
# Every 20 generations, record species abundance octaves
if (i %% interval == 0) {
octaves_max[[length(octaves_max) + 1]] <- octaves(species_abundance(community_max))
octaves_min[[length(octaves_min) + 1]] <- octaves(species_abundance(community_min))
}
}
# Compute mean abundance octaves
mean_octave_max <- Reduce(sum_vect, octaves_max) / length(octaves_max)
mean_octave_min <- Reduce(sum_vect, octaves_min) / length(octaves_min)
# Plot results
png(filename="question_22", width = 600, height = 400)
par(mfrow = c(1, 2))  # Split plot area into two panels
barplot(mean_octave_max, col = "red", main = "Max Diversity Init",
xlab = "Octave", ylab = "Mean Abundance")
barplot(mean_octave_min, col = "blue", main = "Min Diversity Init",
xlab = "Octave", ylab = "Mean Abundance")
Sys.sleep(0.1)
dev.off()
return("The initial condition of the system does not significantly affect the long-term species abundance distribution. Over time, random drift and speciation drive the system towards a characteristic equilibrium state, where the species abundance follows a stable distribution regardless of the initial configuration.")
}
# Challenge question B
Challenge_B <- function() {
png(filename="./Challenge_B.png""Challenge_B.png", width = 600, height = 400)
# Challenge question B
Challenge_B <- function() {
png(filename="./Challenge_B.png", width = 600, height = 400)
# Function to calculate confidence intervals
compute_confidence_interval <- function(data, confidence = 0.972) {
mean_values <- colMeans(data)
sem <- apply(data, 2, function(x) sd(x) / sqrt(length(x)))
ci_range <- qt((1 + confidence) / 2, df = nrow(data) - 1) * sem
return(list(mean = mean_values, lower = mean_values - ci_range, upper = mean_values + ci_range))
}
# Simulation parameters
community_size <- 100
speciation_rate <- 0.1
num_simulations <- 50
duration <- 200
# Store simulation results
richness_max_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
richness_min_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
for (sim in 1:num_simulations) {
community_max <- init_community_max(community_size) # Max diversity
community_min <- init_community_min(community_size) # Min diversity
for (gen in 1:duration) {
community_max <- neutral_generation_speciation(community_max, speciation_rate)
community_min <- neutral_generation_speciation(community_min, speciation_rate)
richness_max_simulations[sim, gen] <- species_richness(community_max)
richness_min_simulations[sim, gen] <- species_richness(community_min)
}
}
# Compute mean and confidence intervals
ci_max <- compute_confidence_interval(richness_max_simulations)
ci_min <- compute_confidence_interval(richness_min_simulations)
# Estimate equilibrium time: when richness change over last 20 generations is <1%
equilibrium_max <- min(which(abs(diff(ci_max$mean[(duration - 20):duration])) < 0.01 * ci_max$mean[duration - 20]))
equilibrium_min <- min(which(abs(diff(ci_min$mean[(duration - 20):duration])) < 0.01 * ci_min$mean[duration - 20]))
equilibrium_gen <- max(ifelse(is.finite(equilibrium_max), equilibrium_max, duration),
ifelse(is.finite(equilibrium_min), equilibrium_min, duration))
# Plot results
plot(
1:duration, ci_max$mean, type="l", col="red", lwd=2,
xlab="Generations", ylab="Species Richness",
main="Species Richness Over Generations with 97.2% CI"
)
lines(1:duration, ci_min$mean, col="blue", lwd=2)
polygon(
c(1:duration, rev(1:duration)),
c(ci_max$upper, rev(ci_max$lower)),
col=rgb(1,0,0,0.2), border=NA
)
polygon(
c(1:duration, rev(1:duration)),
c(ci_min$upper, rev(ci_min$lower)),
col=rgb(0,0,1,0.2), border=NA
)
abline(v=equilibrium_gen, lty=2, col="black")
legend("topright", legend=c("Max Diversity", "Min Diversity"),
col=c("red", "blue"), lwd=2)
dev.off()
# Return equilibrium estimate
return(paste("The system reaches dynamic equilibrium in approximately", equilibrium_gen, "generations."))
}
getwd()
# Challenge question B
Challenge_B <- function() {
png(filename="./Challenge_B.png", width = 600, height = 400)
# Function to calculate confidence intervals
compute_confidence_interval <- function(data, confidence = 0.972) {
mean_values <- colMeans(data)
sem <- apply(data, 2, function(x) sd(x) / sqrt(length(x)))
ci_range <- qt((1 + confidence) / 2, df = nrow(data) - 1) * sem
return(list(mean = mean_values, lower = mean_values - ci_range, upper = mean_values + ci_range))
}
# Simulation parameters
community_size <- 100
speciation_rate <- 0.1
num_simulations <- 50
duration <- 200
# Store simulation results
richness_max_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
richness_min_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
for (sim in 1:num_simulations) {
community_max <- init_community_max(community_size) # Max diversity
community_min <- init_community_min(community_size) # Min diversity
for (gen in 1:duration) {
community_max <- neutral_generation_speciation(community_max, speciation_rate)
community_min <- neutral_generation_speciation(community_min, speciation_rate)
richness_max_simulations[sim, gen] <- species_richness(community_max)
richness_min_simulations[sim, gen] <- species_richness(community_min)
}
}
# Compute mean and confidence intervals
ci_max <- compute_confidence_interval(richness_max_simulations)
ci_min <- compute_confidence_interval(richness_min_simulations)
# Estimate equilibrium time: when richness change over last 20 generations is <1%
equilibrium_max <- min(which(abs(diff(ci_max$mean[(duration - 20):duration])) < 0.01 * ci_max$mean[duration - 20]))
equilibrium_min <- min(which(abs(diff(ci_min$mean[(duration - 20):duration])) < 0.01 * ci_min$mean[duration - 20]))
equilibrium_gen <- max(ifelse(is.finite(equilibrium_max), equilibrium_max, duration),
ifelse(is.finite(equilibrium_min), equilibrium_min, duration))
# Plot results
plot(
1:duration, ci_max$mean, type="l", col="red", lwd=2,
xlab="Generations", ylab="Species Richness",
main="Species Richness Over Generations with 97.2% CI"
)
lines(1:duration, ci_min$mean, col="blue", lwd=2)
polygon(
c(1:duration, rev(1:duration)),
c(ci_max$upper, rev(ci_max$lower)),
col=rgb(1,0,0,0.2), border=NA
)
polygon(
c(1:duration, rev(1:duration)),
c(ci_min$upper, rev(ci_min$lower)),
col=rgb(0,0,1,0.2), border=NA
)
abline(v=equilibrium_gen, lty=2, col="black")
legend("topright", legend=c("Max Diversity", "Min Diversity"),
col=c("red", "blue"), lwd=2)
dev.off()
# Return equilibrium estimate
return(paste("The system reaches dynamic equilibrium in approximately", equilibrium_gen, "generations."))
}
# Challenge question B
Challenge_B <- function() {
png(filename="Challenge_B.png", width = 600, height = 400)
# Function to calculate confidence intervals
compute_confidence_interval <- function(data, confidence = 0.972) {
mean_values <- colMeans(data)
sem <- apply(data, 2, function(x) sd(x) / sqrt(length(x)))
ci_range <- qt((1 + confidence) / 2, df = nrow(data) - 1) * sem
return(list(mean = mean_values, lower = mean_values - ci_range, upper = mean_values + ci_range))
}
# Simulation parameters
community_size <- 100
speciation_rate <- 0.1
num_simulations <- 50
duration <- 200
# Store simulation results
richness_max_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
richness_min_simulations <- matrix(NA, nrow = num_simulations, ncol = duration)
for (sim in 1:num_simulations) {
community_max <- init_community_max(community_size) # Max diversity
community_min <- init_community_min(community_size) # Min diversity
for (gen in 1:duration) {
community_max <- neutral_generation_speciation(community_max, speciation_rate)
community_min <- neutral_generation_speciation(community_min, speciation_rate)
richness_max_simulations[sim, gen] <- species_richness(community_max)
richness_min_simulations[sim, gen] <- species_richness(community_min)
}
}
# Compute mean and confidence intervals
ci_max <- compute_confidence_interval(richness_max_simulations)
ci_min <- compute_confidence_interval(richness_min_simulations)
# Estimate equilibrium time: when richness change over last 20 generations is <1%
equilibrium_max <- min(which(abs(diff(ci_max$mean[(duration - 20):duration])) < 0.01 * ci_max$mean[duration - 20]))
equilibrium_min <- min(which(abs(diff(ci_min$mean[(duration - 20):duration])) < 0.01 * ci_min$mean[duration - 20]))
equilibrium_gen <- max(ifelse(is.finite(equilibrium_max), equilibrium_max, duration),
ifelse(is.finite(equilibrium_min), equilibrium_min, duration))
# Plot results
plot(
1:duration, ci_max$mean, type="l", col="red", lwd=2,
xlab="Generations", ylab="Species Richness",
main="Species Richness Over Generations with 97.2% CI"
)
lines(1:duration, ci_min$mean, col="blue", lwd=2)
polygon(
c(1:duration, rev(1:duration)),
c(ci_max$upper, rev(ci_max$lower)),
col=rgb(1,0,0,0.2), border=NA
)
polygon(
c(1:duration, rev(1:duration)),
c(ci_min$upper, rev(ci_min$lower)),
col=rgb(0,0,1,0.2), border=NA
)
abline(v=equilibrium_gen, lty=2, col="black")
legend("topright", legend=c("Max Diversity", "Min Diversity"),
col=c("red", "blue"), lwd=2)
dev.off()
# Return equilibrium estimate
return(paste("The system reaches dynamic equilibrium in approximately", equilibrium_gen, "generations."))
}
# Question 8
init_community_max <- function(size){
max_species = seq_len(size)
return(max_species)
}
# Question 9
init_community_min <- function(size){
min_species = rep(1,size)
return(min_species)
}
# Question 17
neutral_time_series_speciation <- function(community,speciation_rate,duration)  {
# Initialize a vector to store species richness for each generation.
# The vector has length duration + 1 to include the initial condition.
richness_series <- numeric(duration + 1)
# Record the species richness of the initial community.
richness_series[1] <- length(unique(community))
# Loop over each generation.
for (i in 1:duration) {
# Advance the community one generation using the neutral model with speciation.
community <- neutral_generation_speciation(community, speciation_rate)
# Record the species richness (number of unique species) after this generation.
richness_series[i + 1] <- length(unique(community))
}
# Return the time series vector of species richness.
return(richness_series)
}
setwd()
setwd("~/Desktop/HPC")
# Question 18
question_18 <- function() {
png(filename = "question_18.png", width = 600, height = 400)
# plot your graph here
# Set simulation parameters
community_size <- 100
speciation_rate <- 0.1
duration <- 200
# Create two different initial communities:
# - Maximal diversity: each individual is a unique species.
community_max <- init_community_max(community_size)
# - Minimal diversity: all individuals belong to the same species.
community_min <- init_community_min(community_size)
# Run the simulation with speciation for both initial conditions.
# neutral_time_series_speciation returns a vector of species richness over generations.
richness_max <- neutral_time_series_speciation(community_max, speciation_rate, duration)
richness_min <- neutral_time_series_speciation(community_min, speciation_rate, duration)
# Plot the time series for the maximal diversity initial condition in red.
plot(richness_max, type = "l", col = "red", lwd = 2,
xlab = "Generation", ylab = "Species Richness",
main = "Neutral Model Simulation with Speciation")
# Overlay the time series for the minimal diversity initial condition in blue.
lines(richness_min, type = "l", col = "blue", lwd = 2)
# Add a legend to differentiate the two curves.
legend("topright", legend = c("Max Diversity", "Min Diversity"),
col = c("red", "blue"), lwd = 2)
Sys.sleep(0.1)
dev.off()
return("The plot demonstrates that regardless of whether the simulation starts with maximal or minimal diversity, the neutral model with speciation converges to a similar dynamic equilibrium in species richness over time. This occurs because the stochastic processes of random drift and speciation eventually override the influence of the initial conditions, leading to a characteristic equilibrium state.")
}
View(question_18)
