Starting code feedback for Yaxin, Week1

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.53 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week1, Feedback, .git

Found the following files in parent directory: README.md

Checking for key files in parent directory...

.gitignore missing, 1 pt deducted

Current Points = 99

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
my CMEE Coursework Repository

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 1 weekly directories: week1

The Week1 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK1...

Found the following directories: data, results, sandbox, code

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
Project name / title : week1 Practicals of unix and shell script

Brief description: 

    This project is focused on basic UNIX programming practice and shell scripting exercises. 

Languages:

    UNIX Command and Shell script

Project structure and Usage:

    This folder contains four parts : code, data, results, sandbox

    All the codes for achieve the pritical tasks are in the "code" folder ;

    The data which will be used to test or run the code are stored in "data" folder ;

    The outputs that generated by running the codes will go to "results" folder ;

    As for the "sandbox" folder, it is for some drafts and other ones.

    Please see the detailed guidlines in each folder's README file.

Author name and contact 
    
    Yaxin  yaxin.liu24@imperial.ac.uk
**********************************************************************

Found following files in results directory: README.md...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 98.5

Found 8 code files: csvtospace.sh, variables.sh, CountLines.sh, tiff2png.sh, tabtocsv.sh, UnixPrac1.txt, MyExampleScript.sh, ConcatenateTwoFiles.sh

Found the following extra files: README.md
0.5 pt deducted per extra file

Current Points = 98.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file csvtospace.sh...

File contents are:

**********************************************************************
#!/bin/bash
# Author: Yaxin yaxin.liu24@imperial.ac.uk
# Script: csvtospace.sh
# Description: Convert CSV file to space-separated values file.
# Arguments: 1 -> Input CSV file
# Date: Oct 2024
# Function to display usage information

# Check if correct number of arguments is provided
# "$#" gives the total number of arguments that were passed to the script when it was executed.
if [ $# -ne 1 ]; then 
    echo "Error: Wrong number of arguments."
    usage
    exit 1
fi

input_file="$1"

# Check if the input file exists and is readable
# "!" negates the condition
# -f (file): This operator tests if a file exists and is a regular file
if [ ! -f "$input_file" ]; then
    echo "Error: Input file '$input_file' does not exist."
    exit 1
fi

# tests for the opposite of "readable". It's true if the file either doesn't exist or exists but is not readable
if [ ! -r "$input_file" ]; then
    echo "Error: Input file '$input_file' is not readable."
    exit 1
fi
# Define the output directory (relative path)
output_dir="../results"
# Create the output directory if it doesn't exist
mkdir -p "$output_dir"

# Get the base name of the input file
base_name=$(basename "$input_file")

# Create output filename 
output_file="$output_dir/${base_name%.csv}.csv"

# Convert CSV to space-separated values
if ! tr ',' ' ' < "$input_file" > "$output_file"; then
    echo "Error: Failed to convert the file."
    exit 1
fi

echo "Successfully converted '$input_file' to '$output_file'"

**********************************************************************

Testing csvtospace.sh...

Output (only first 500 characters): 


**********************************************************************
Error: Wrong number of arguments.

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

csvtospace.sh: line 13: usage: command not found

======================================================================
Inspecting script file variables.sh...

File contents are:

**********************************************************************

**********************************************************************

Testing variables.sh...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.00401s

======================================================================
Inspecting script file CountLines.sh...

File contents are:

**********************************************************************
#!/bin/sh
# Author: Yaxin yaxin.liu24@imperial.ac.uk
# Script: CountLines.sh
# Desc: Count the number of lines in the file
# Arguments: <input_file> 
# Date: Oct 2024

# Check if exactly one argument is provided
# "$#": This holds the count of arguments passed to the script.
# -ne: This means "not equal."
# 1: the expected number of arguments.

if [ "$#" -ne 1 ]; then
    echo "Error: Please provide exactly one input file."
    usage
    exit 1
fi

# Check if the file exists and is readable
# -f filename: checks if the specified filename exists and is a regular file 
# -r filename: checks if the specified filename exists and is readable by the user running the script
if [ ! -f "$1" ]; then
    echo "Error: File '$1' does not exist or is not a regular file."
    exit 1
fi

if [ ! -r "$1" ]; then
    echo "Error: File '$1' is not readable."
    exit 1
fi

# Count the number of lines in the file
# wc: word count -l: count only the number of lines.
NumLines=$(wc -l < "$1")

# Display the result
echo "The file '$1' has $NumLines line(s)."


**********************************************************************

Testing CountLines.sh...

Output (only first 500 characters): 


**********************************************************************
Error: Please provide exactly one input file.

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

CountLines.sh: line 15: usage: command not found

======================================================================
Inspecting script file tiff2png.sh...

File contents are:

**********************************************************************

**********************************************************************

Testing tiff2png.sh...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.00358s

======================================================================
Inspecting script file tabtocsv.sh...

File contents are:

**********************************************************************
#!/bin/sh
# Author: Yaxin yaxin.liu24@imperial.ac.uk
# Script: tabtocsv.sh
# Description: substitute the tabs in the files with commas

# Saves the output into a .csv file
# Arguments: 1 -> tab delimited file
# Date: Oct 2024
# Check if the input file is provided
# Check if correct number of arguments is provided
# Function to display usage information

# Check if correct number of arguments is provided
# "$#" gives the total number of arguments that were passed to the script when it was executed.
if [ $# -eq 0 ]; then
    echo "Error: No input file provided."
    usage
    exit 1
fi

if [ $# -ne 1 ]; then
    echo "Error: Incorrect number of arguments."
    usage
    exit 1
fi

input_file="$1"

# "!" negates the condition
# -f (file): This operator tests if a file exists and is a regular file
if [ ! -f "$input_file" ]; then
    echo "Error: Input file '$input_file' does not exist."
    exit 1
fi

# Create the output directory if it doesn't exist
# mkdir: command used to create new directories.
# -p: allows the creation of nested directories and prevents errors if the directory already exists.
output_dir="$(dirname "$0")/../results"
mkdir -p "$output_dir" || { echo "Error: Failed to create output directory."; exit 1; }
    
#basename: used in scripts when need to manipulate file names
base_name=$(basename "$input_file")

#*: matches zero or more characters in file or directory names.
if [[ "$base_name" != *.csv ]]; then
    echo "Error: Input file must have a .csv extension."
    exit 1
fi

output_file="$output_dir/${base_name%.csv}.txt"

#tr ',' ' ': uses translate or delete characters to replace "," with spaces in the input.
#< "$input_file": redirects the contents of the file specified by "$input_file" as input to the tr command.
#> "$output_file": redirects the output of the tr command to the file specified by "$output_file", creating or overwriting that file.
if ! tr ',' ' ' < "$input_file" > "$output_file"; then
    echo "Error: Failed to convert the file."
    exit 1
fi

echo "Successfully converted '$input_file' to '$output_file'"
**********************************************************************

Testing tabtocsv.sh...

Output (only first 500 characters): 


**********************************************************************
Error: No input file provided.

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

tabtocsv.sh: line 17: usage: command not found

======================================================================
Inspecting script file UnixPrac1.txt...

File contents are:

**********************************************************************
cd ~/documents/CMEECoursework/week1/data

# 1
# wc: word count -l: count only the number of lines.
# * :  matches zero or more characters in file or directory names.

wc -l *.fasta

# 2
# cat: reads the contents of the file and sends it to the terminal
# | : takes the output of the command on its left and uses it as input for the command on its right.
# tail is a command that outputs the last part of a file. 
# The "-n +2" option tells tail to start outputting from line 2 onward (it skips the first line)

cat E.coli.fasta | tail -n +2

#3
# wc: word count -c: specifies that you want to count bytes.

tail -n +2 E.coli.fasta | wc -c

#4
# tr -d "\n": translates (or deletes) newline characters from the input. As a result, it combines all the lines into a single line of text.
# grep: searches for occurrences of the string 
# -o: tells grep to only output the matched parts, one per line.

tail -n +2 E.coli.fasta | tr -d "\n" | grep -o ATGC | wc -l

#5
# counts the occurrences of nucleotides A and T, counts the occurrences of G and C, calculates the ratio of A + T to G + C, and then prints that ratio.

Count_AT=$(grep -o '[AT]' E.coli.fasta | wc -l); Count_GC=$(grep -o '[GC]' E.coli.fasta | wc -l); ratio_final=$(echo "scale=5; $Count_AT/$Count_GC" | bc); echo $ratio_final
**********************************************************************

Testing UnixPrac1.txt...

======================================================================
Inspecting script file MyExampleScript.sh...

File contents are:

**********************************************************************
#!/bin/sh

MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"
echo "Hello $USER"
echo
**********************************************************************

Testing MyExampleScript.sh...

Output (only first 500 characters): 


**********************************************************************
Hello mhasoba
Hello mhasoba


**********************************************************************

Code ran without errors

Time consumed = 0.00766s

======================================================================
Inspecting script file ConcatenateTwoFiles.sh...

File contents are:

**********************************************************************
#!/bin/sh
# Author: Yaxin yaxin.liu24@imperial.ac.uk
# Script: ConcatenateTwoFiles.sh
# Desc: Concatenate the two input files into the output file
# Arguments: <input_file1> [input_file2] ...
# Date: Oct 2024

# Check if exactly two arguments are provided
# "$#": This holds the count of arguments passed to the script.
# -ne: This means "not equal."
# 2: the expected number of arguments.

if [ "$#" -ne 2 ]; then
    echo "Error: Please provide exactly two input files."
    echo "Usage: $0 <input_file1> <input_file2>"
    exit 1
fi

# Define the output directory (relative path)
output_dir="../results"

# Create the output directory if it doesn't exist
# mkdir: command used to create new directories.
# -p: allows the creation of nested directories and prevents errors if the directory already exists.

mkdir -p "$output_dir"

# Check if the input files exist
for file in "$1" "$2"; do
    if [ ! -f "$file" ]; then
        echo "Error: File '$file' does not exist."
        exit 1
    fi
done

# Define the output file name and path
output_file="$output_dir/merged_output.txt"

# Concatenate the two input files into the output file
# cat: reads the contents of the file specified and outputs it to standard output
# >: This operator redirects the output to a file
# >>: This operator appends the output to the specified file rather than overwriting it
cat "$1" > "$output_file"
cat "$2" >> "$output_file"

echo "Merged File is saved as: $output_file"
**********************************************************************

Testing ConcatenateTwoFiles.sh...

Output (only first 500 characters): 


**********************************************************************
Error: Please provide exactly two input files.
Usage: ConcatenateTwoFiles.sh <input_file1> <input_file2>

**********************************************************************

Code ran without errors

Time consumed = 0.00365s

======================================================================
======================================================================
Finished running scripts

Ran into 3 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 98.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!